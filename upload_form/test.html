
<script async type="text/javascript" src="../upload_form/filecheck.js"></script>
<script type="text/javascript">
    function uploaded() {
        reset2();
        var uploadform = document.getElementById("fileuploadform");
        var filename = uploadform.files[0].name;
        var fr = new FileReader();

        fr.onload = function (){
            var stl_name = filename;

            var data = atob(fr.result.split(",")[1]); // base64 to Uint8 for emscripten

            var check_report = new Int32Array([
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
            ]);
            var check_report_heapBytes = _arrayToHeap(check_report);

            var boundary = new Float32Array([
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0
            ]);
            var boundary_heapBytes = _arrayToHeap(boundary);

            var repair_report = new Int32Array([
                    -1,
                    -1
            ]);
            var repair_report_heapBytes = _arrayToHeap(repair_report);

            Module['FS_createDataFile'](".", stl_name, data, true, true);

            Module.ccall("file_check_repair", // c function name
                    undefined, // return
                    ["string", "number", "number", "number"], // param
                    [stl_name,
                     check_report_heapBytes.byteOffset,
                     boundary_heapBytes.byteOffset,
                     repair_report_heapBytes.byteOffset
                    ]
            );

            // TODO: if you use allow_memory_grow when compile the js code, the int array's first memory location will changed! thus it will look like the result is not set!
            var check_report = new Int32Array(check_report_heapBytes.buffer, check_report_heapBytes.byteOffset, check_report.length);
            var boundary = new Float32Array(boundary_heapBytes.buffer, boundary_heapBytes.byteOffset, boundary.length);
            var repair_report = new Int32Array(boundary_heapBytes.buffer, repair_report_heapBytes.byteOffset, repair_report.length);

            console.log(check_report);
            console.log(boundary);
            console.log(repair_report);

            update_from_result(check_report, repair_report);

            _freeArray(check_report_heapBytes);
            _freeArray(boundary_heapBytes);
            _freeArray(repair_report_heapBytes);

            download_repaired(stl_name);
        };

        fr.readAsDataURL(uploadform.files[0]);
    }

    function download_repaired(stl_name) {
        // var uint8array = Module['FS_readFile'](stl_name, { encoding: 'binary' });
        // console.log(uint8array);
        // var r_string = new TextDecoder("utf8").decode(uint8array);
        // console.log(r_string);
        // var base64_string = btoa(r_string);
        // console.log(base64_string);
        // download("repaired_" + stl_name, base64_string);

        // var uint8array = Module['FS_readFile'](stl_name, { encoding: 'binary' });
        // console.log(uint8array);
        // var r_string = new TextDecoder("utf8").decode(uint8array);
        // console.log(r_string);
        // var base64_string = btoa(r_string);
        // console.log(base64_string);
        // download("repaired_" + stl_name, base64_string);


        var uint8array = Module['FS_readFile']("repaired.stl", { encoding: 'binary' });
        var base64_string = Uint8ToString(uint8array);
        download("repaired_"+stl_name, btoa(base64_string));
    }

    function _arrayToHeap(typedArray){
        var numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
        var ptr = Module._malloc(numBytes);
        var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
        heapBytes.set(new Uint8Array(typedArray.buffer));
        return heapBytes;
    }
    function _freeArray(heapBytes){
        Module._free(heapBytes.byteOffset);
    }

    function update_from_result(result, repair_report) {
        const repair_divs = document.getElementsByClassName("repair");
        for (var i=0;i<repair_divs.length;i++) {
            repair_divs[i].style.display = "None";
        }

        const num_degen_faces = result[3];
        const num_dup_faces = result[4];
        const is_manifold = result[5];
        const is_consistent_normal = result[6];
        const is_volume_bigger_0 = result[7];

        const fix_consistent_normal = repair_report[0];
        const fix_volume_bigger_0 = repair_report[1];

        filecheck_outint_step(num_degen_faces, degenfaces);

        if (num_degen_faces >0) {
            set_repair_bool_func(remove_num, degenfaces, num_degen_faces);
            _repair(degenfaces);
        }

        filecheck_outint_step(num_dup_faces, dupfaces,);

        if (num_dup_faces > 0) {
            set_repair_bool_func(remove_num, dupfaces, num_dup_faces);
            _repair(dupfaces);
        }

        filecheck_outint_step(is_manifold, manifold);
        filecheck_outint_step(is_consistent_normal, consisnormal);

        if (fix_consistent_normal !== -1) {
            if (fix_consistent_normal) {
                set_repair_bool_func(fix, consisnormal);
                _repair(consisnormal);
            } else if (fix_consistent_normal !== -1){
                filecheck_outint_step(1, volume);
            }
        }

        filecheck_outint_step(is_volume_bigger_0, volume);

        if (fix_volume_bigger_0 !== -1) {
            if (fix_volume_bigger_0) {
                set_repair_bool_func(fix, volume);
                _repair(volume);
                filecheck_outint_step(0, volume);
            } else if (fix_volume_bigger_0 !== -1){
                filecheck_outint_step(1, volume);
            }
        }
    }

    function degenfaces() {return "dengenerated faces";}
    function dupfaces() {return "duplicate faces";}
    function manifold() {return "manifold";}
    function consisnormal() {return "consistent normal";}
    function volume() {return "volume bigger 0";}

    function check_for(f) {return `Check for ${f()}`;}
    function repair_for(f) {return `Repair for ${f()}`;}

    function is(f) {return `Is ${f()}`;};
    function no(f) {return `No ${f()}`;};
    function has(f) {return `has ${f()}`;};
    function not(f) {return `Not ${f()}`;};
    function fix(f) {return `Fix ${f()}`;};

    function _true(f) {
        document.getElementById("condition" + f.name).style.backgroundColor = "green";

        if ([degenfaces, dupfaces].includes(f))
            return no(f);
        else
            return is(f);
    }

    function _false(f) {
        document.getElementById("condition" + f.name).style.backgroundColor = "red";
        document.getElementById("down" + f.name).style.display = "None";

        if ([degenfaces, dupfaces].includes(f))
            return has(f);
        else
            return not(f);
    }

    function _repair(f) {
        document.getElementById("repair" + f.name).style.backgroundColor = "green";
        document.getElementById("container" + f.name).style.display = "";
    }

    function remove_num(f, num) {return `removed ${num} ${f()}`};

    function set_id_str(id, str) {
        document.getElementById(id).innerHTML = str;
        document.getElementById(id).style.display = "";
    }

    function set_name_id_str(name, bool, func, ...args) {
        return set_id_str(name + func.name, bool(func, ...args));
    }

    function set_condition_bool_func(...args) {
        return set_name_id_str("condition", ...args)
    }

    function set_repair_bool_func(...args) {
        return set_name_id_str("repair", ...args)
    }

    function filecheck_outint_step(outint, func) {
        if (outint === -1) {
            // console.error(`${func()} check is not run`);
            console.log(`${func()} check is not run`);
        } else { // this is hack put the degen faces number to result array
            if ([degenfaces, dupfaces].includes(func)) {
                if (outint === 0) {
                    set_condition_bool_func(_true, func);
                } else { // outint >= 1
                    set_condition_bool_func(_false, func);
                }
            } else {
                if (outint === 0) {
                    set_condition_bool_func(_false, func);
                } else { // outint >= 1
                    set_condition_bool_func(_true, func);
                }
            }
        }
    }

    function reset() {
        var res = document.getElementsByClassName("condition");
        for (var i=0;i<res.length;i++) {
            res[i].style.backgroundColor = "grey";
            res[i].innerHTML = "";
        }

        var res = document.getElementsByClassName("repair");
        for (var i=0;i<res.length;i++) {
            res[i].style.display = "None";
        }
    }

    function reset2() {
        console.log("reset");
        const to_empty = document.getElementById("content");
        while (to_empty.firstChild) {
            to_empty.removeChild(to_empty.firstChild);
        }

        init();
    }
    function download(filename, text) {

        var pom = document.getElementById('download');
        pom.setAttribute('href', 'data:application/sla;base64,' + text);
        pom.setAttribute('download', filename);

        // if (document.createEvent) {
                // var event = document.createEvent('MouseEvents');
                // event.initEvent('click', true, true);
                // pom.dispatchEvent(event);
            // }
        // else {
                // pom.click();
            // }
    }

    function init() {
        const funcs = [degenfaces, dupfaces, manifold, consisnormal, volume];
        for (let i=0; i < funcs.length; i++) {
            const func = funcs[i];
            const func_name = funcs[i].name;

            let temp = document.getElementsByTagName("template")[0];

            let container = temp.content.querySelector(".left");
            container.id = "condition" + func_name;
            container.innerHTML = check_for(func);

            let repair_div = temp.content.querySelector(".repair");
            repair_div.id = "container" + func_name;

            let repair_right_div = temp.content.querySelector(".right");
            repair_right_div.id = "repair" + func_name;
            repair_right_div.innerHTML = repair_for(func);

            let arrow_down = temp.content.querySelector(".a_down");
            arrow_down.id = "down" + func_name;

            const to_add = document.importNode(temp.content, true);
            document.getElementById("content").appendChild(to_add);
        }
    }

    // https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string
    // TODO: figure out why TextDecoder doesn't work
    // apply fail since big stack
    function Uint8ToString(u8a){
      var CHUNK_SZ = 0x8000;
      var c = [];
      for (var i=0; i < u8a.length; i+=CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i+CHUNK_SZ)));
        }
        return c.join("");
    }

</script>

<html>
<head>
<style>

#content {
    width: 300px;
}
.condition {
    width: 100px;
    height: 70px;
    background-color: grey;
}
.container {
    width: 220px;
    height: 70px;
    display: inline-block;
    margin: 1px;
}

.arrow {
    border: solid black;
    border-width: 0 3px 3px 0;
    display: inline-block;
    padding: 3px;
}

.a_down {
    transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
}

.a_right {
    transform: rotate(-45deg);
    -webkit-transform: rotate(-45deg);
    margin-top:30px;
    margin-left:3px;
}

.a_left {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    margin-top:40px;
    margin-left:4px;
}

.left {
    float: left;
}
.right {
    float: right;
}

.downArrowContainer {
    height: 15px;
    margin-bottom: 5px;
    margin-top: 5px;
    margin-left: 45px;
}

.rightArrowContainer {
    width: 15px;
    height: 70px; /* inherit from container */
    float: left;
}

#download {
    width: 200px;
    height: 50px; /* inherit from container */
}

</style>
</head>
<input type="file" onChange="uploaded()" id="fileuploadform"/>

<body onload="init()">

    <template id="container">
        <div>
            <div class="container">
                <div class="condition left"><p></p></div>
                <div class="repair" >
                    <div class="rightArrowContainer">
                        <i class="arrow a_right"></i>
                        <i class="arrow a_left"></i>
                    </div>
                    <div class="condition right"></div>
                </div>
            </div>

            <div class="downArrowContainer">
                <i class="arrow a_down"></i>
            </div>
        <div>
    </template>

    <div id="content"></div>
    <a id="download"><button>Click to download repaired file</button></a>
</body>
</html>
